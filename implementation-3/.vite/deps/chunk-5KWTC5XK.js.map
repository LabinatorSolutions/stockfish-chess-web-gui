{
  "version": 3,
  "sources": ["../../node_modules/cm-web-modules/src/observe/Observe.js"],
  "sourcesContent": ["/**\n * Author and copyright: Stefan Haack (https://shaack.com)\n * Repository: https://github.com/shaack/cm-web-modules\n * License: MIT, see file 'LICENSE'\n */\n\nconst collectionMutationMethods = {\n    array: [\"copyWithin\", \"fill\", \"pop\", \"push\", \"reverse\", \"shift\", \"unshift\", \"sort\", \"splice\"],\n    set: [\"add\", \"clear\", \"delete\"],\n    map: [\"set\", \"clear\", \"delete\"]\n}\n\nconst registry = new Map()\n\nexport class Observe {\n\n    /**\n     * Intercept a function call before the function is executed. Can manipulate\n     * arguments in callback.\n     * @param object\n     * @param functionName allows multiple names as array\n     * @param callback\n     * @returns Object with `remove` function to remove the interceptor\n     */\n    static preFunction(object, functionName, callback) {\n        if (Array.isArray(functionName)) {\n            let removes = []\n            functionName.forEach((functionNameItem) => {\n                removes.push(Observe.preFunction(object, functionNameItem, callback))\n            })\n            return {\n                remove: () => {\n                    removes.forEach((remove) => {\n                        remove.remove()\n                    })\n                }\n            }\n        }\n        if (!registry.has(object)) {\n            registry.set(object, {})\n        }\n        const registryObject = registry.get(object)\n        if (registryObject.observedPreFunctions === undefined) {\n            registryObject.observedPreFunctions = new Map()\n        }\n        if (!registryObject.observedPreFunctions.has(functionName)) {\n            registryObject.observedPreFunctions.set(functionName, new Set())\n            const originalMethod = object[functionName]\n            object[functionName] = function () {\n                let functionArguments = arguments\n                registryObject.observedPreFunctions.get(functionName).forEach(function (callback) {\n                    const params = {functionName: functionName, arguments: functionArguments}\n                    const callbackReturn = callback(params)\n                    if (callbackReturn) {\n                        functionArguments = callbackReturn\n                    }\n                })\n                return originalMethod.apply(object, functionArguments)\n            }\n        }\n        registryObject.observedPreFunctions.get(functionName).add(callback)\n        return {\n            remove: () => {\n                registryObject.observedPreFunctions.get(functionName).delete(callback)\n            }\n        }\n    }\n\n    /**\n     * Intercept a function call after the function is executed. Can manipulate\n     * returnValue in callback.\n     * @param object\n     * @param functionName allows multiple names as array\n     * @param callback\n     * @returns Object with `remove` function to remove the interceptor\n     */\n    static postFunction(object, functionName, callback) {\n        if (Array.isArray(functionName)) {\n            let removes = []\n            functionName.forEach((functionNameItem) => {\n                removes.push(Observe.postFunction(object, functionNameItem, callback))\n            })\n            return {\n                remove: () => {\n                    removes.forEach((remove) => {\n                        remove.remove()\n                    })\n                }\n            }\n        }\n        if (!registry.has(object)) {\n            registry.set(object, {})\n        }\n        const registryObject = registry.get(object)\n        if (registryObject.observedPostFunctions === undefined) {\n            registryObject.observedPostFunctions = new Map()\n        }\n        if (!registryObject.observedPostFunctions.has(functionName)) {\n            registryObject.observedPostFunctions.set(functionName, new Set())\n            const originalMethod = object[functionName]\n            object[functionName] = function () {\n                let returnValue = originalMethod.apply(object, arguments)\n                const functionArguments = arguments\n                registryObject.observedPostFunctions.get(functionName).forEach(function (callback) {\n                    const params = {functionName: functionName, arguments: functionArguments, returnValue: returnValue}\n                    callback(params)\n                    returnValue = params.returnValue // modifiable if called synced\n                })\n                return returnValue\n            }\n        }\n        registryObject.observedPostFunctions.get(functionName).add(callback)\n        return {\n            remove: () => {\n                registryObject.observedPostFunctions.get(functionName).delete(callback)\n            }\n        }\n    }\n\n    /**\n     * Observe properties (attributes) of an object. Works also with Arrays, Maps and Sets.\n     * The parameter `propertyName` can be an array of names to observe multiple properties.\n     * @param object\n     * @param propertyName allows multiple names as array\n     * @param callback\n     */\n    static property(object, propertyName, callback) {\n        // console.warn(\"`Observe` was deprecated at 2022-06-29, use `Observed`\")\n        if (Array.isArray(propertyName)) {\n            let removes = []\n            propertyName.forEach((propertyNameItem) => {\n                removes.push(Observe.property(object, propertyNameItem, callback))\n            })\n            return {\n                remove: () => {\n                    removes.forEach((remove) => {\n                        remove.remove()\n                    })\n                }\n            }\n        }\n        if (!object.hasOwnProperty(propertyName)) {\n            console.error(\"Observe.property\", object, \"missing property: \" + propertyName)\n            return\n        }\n        let isCollection = false\n        if (!registry.has(object)) {\n            registry.set(object, {})\n        }\n        const registryObject = registry.get(object)\n        if (registryObject.observedProperties === undefined) {\n            registryObject.observedProperties = new Map()\n        }\n        if (!registryObject.observedProperties.has(propertyName)) {\n            registryObject.observedProperties.set(propertyName, {\n                value: object[propertyName],\n                observers: new Set()\n            });\n\n            const property = object[propertyName]\n            let mutationMethods = []\n            if (property instanceof Array) {\n                isCollection = true\n                mutationMethods = collectionMutationMethods.array\n            } else if (property instanceof Set || property instanceof WeakSet) {\n                isCollection = true\n                mutationMethods = collectionMutationMethods.set\n            } else if (property instanceof Map || property instanceof WeakMap) {\n                isCollection = true\n                mutationMethods = collectionMutationMethods.map\n            }\n            if (delete object[propertyName]) { // handling for simple properties\n                Object.defineProperty(object, propertyName, {\n                    get: function () {\n                        return registryObject.observedProperties.get(propertyName).value\n                    },\n                    set: function (newValue) {\n                        const oldValue = registryObject.observedProperties.get(propertyName).value\n                        if (newValue !== oldValue) {\n                            registryObject.observedProperties.get(propertyName).value = newValue\n                            registryObject.observedProperties.get(propertyName).observers.forEach(function (callback) {\n                                const params = {propertyName: propertyName, oldValue: oldValue, newValue: newValue}\n                                callback(params)\n                            })\n                        }\n                    },\n                    enumerable: true,\n                    configurable: true\n                })\n                if (isCollection) { // handling for Collections\n                    mutationMethods.forEach(function (methodName) {\n                        object[propertyName][methodName] = function () {\n                            // object[propertyName].constructor.prototype[methodName] is Array or Set or...\n                            // noinspection JSPotentiallyInvalidConstructorUsage\n                            object[propertyName].constructor.prototype[methodName].apply(this, arguments)\n                            const methodArguments = arguments\n                            registryObject.observedProperties.get(propertyName).observers.forEach(function (observer) {\n                                const params = {\n                                    propertyName: propertyName,\n                                    methodName: methodName,\n                                    arguments: methodArguments,\n                                    newValue: object[propertyName]\n                                }\n                                observer(params)\n                            })\n                        }\n                    })\n                }\n            } else {\n                console.error(\"Error: Observe.property\", propertyName, \"failed\")\n            }\n        }\n        registryObject.observedProperties.get(propertyName).observers.add(callback)\n        return {\n            remove: () => {\n                registryObject.observedProperties.get(propertyName).observers.delete(callback)\n            }\n        }\n    }\n}\n"],
  "mappings": "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",
  "names": ["callback"]
}
