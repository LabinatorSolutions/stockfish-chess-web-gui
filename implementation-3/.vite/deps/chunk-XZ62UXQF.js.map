{
  "version": 3,
  "sources": ["../../node_modules/chess.mjs/src/Chess.js"],
  "sourcesContent": ["/*\n * Copyright (c) 2022, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n *----------------------------------------------------------------------------*/\n\nconst SYMBOLS = 'pnbrqkPNBRQK'\n\nconst DEFAULT_POSITION =\n    'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\nconst TERMINATION_MARKERS = ['1-0', '0-1', '1/2-1/2', '*']\n\nconst PAWN_OFFSETS = {\n    b: [16, 32, 17, 15],\n    w: [-16, -32, -17, -15],\n}\n\nconst PIECE_OFFSETS = {\n    n: [-18, -33, -31, -14, 18, 33, 31, 14],\n    b: [-17, -15, 17, 15],\n    r: [-16, 1, 16, -1],\n    q: [-17, -16, -15, 1, 17, 16, 15, -1],\n    k: [-17, -16, -15, 1, 17, 16, 15, -1],\n}\n\n// prettier-ignore\nconst ATTACKS = [\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    24, 24, 24, 24, 24, 24, 56, 0, 56, 24, 24, 24, 24, 24, 24, 0,\n    0, 0, 0, 0, 0, 2, 53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 20, 2, 24, 2, 20, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 20, 0, 0, 24, 0, 0, 20, 0, 0, 0, 0, 0,\n    0, 0, 0, 20, 0, 0, 0, 24, 0, 0, 0, 20, 0, 0, 0, 0,\n    0, 0, 20, 0, 0, 0, 0, 24, 0, 0, 0, 0, 20, 0, 0, 0,\n    0, 20, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 20, 0, 0,\n    20, 0, 0, 0, 0, 0, 0, 24, 0, 0, 0, 0, 0, 0, 20\n]\n\n// prettier-ignore\nconst RAYS = [\n    17, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 15, 0,\n    0, 17, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 15, 0, 0,\n    0, 0, 17, 0, 0, 0, 0, 16, 0, 0, 0, 0, 15, 0, 0, 0,\n    0, 0, 0, 17, 0, 0, 0, 16, 0, 0, 0, 15, 0, 0, 0, 0,\n    0, 0, 0, 0, 17, 0, 0, 16, 0, 0, 15, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 17, 0, 16, 0, 15, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 17, 16, 15, 0, 0, 0, 0, 0, 0, 0,\n    1, 1, 1, 1, 1, 1, 1, 0, -1, -1, -1, -1, -1, -1, -1, 0,\n    0, 0, 0, 0, 0, 0, -15, -16, -17, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, -15, 0, -16, 0, -17, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, -15, 0, 0, -16, 0, 0, -17, 0, 0, 0, 0, 0,\n    0, 0, 0, -15, 0, 0, 0, -16, 0, 0, 0, -17, 0, 0, 0, 0,\n    0, 0, -15, 0, 0, 0, 0, -16, 0, 0, 0, 0, -17, 0, 0, 0,\n    0, -15, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, -17, 0, 0,\n    -15, 0, 0, 0, 0, 0, 0, -16, 0, 0, 0, 0, 0, 0, -17\n]\n\nconst SHIFTS = {p: 0, n: 1, b: 2, r: 3, q: 4, k: 5}\n\nconst BITS = {\n    NORMAL: 1,\n    CAPTURE: 2,\n    BIG_PAWN: 4,\n    EP_CAPTURE: 8,\n    PROMOTION: 16,\n    KSIDE_CASTLE: 32,\n    QSIDE_CASTLE: 64,\n}\n\nconst RANK_1 = 7\nconst RANK_2 = 6\nconst RANK_3 = 5\nconst RANK_4 = 4\nconst RANK_5 = 3\nconst RANK_6 = 2\nconst RANK_7 = 1\nconst RANK_8 = 0\n\n// prettier-ignore\nconst SQUARE_MAP = {\n    a8: 0, b8: 1, c8: 2, d8: 3, e8: 4, f8: 5, g8: 6, h8: 7,\n    a7: 16, b7: 17, c7: 18, d7: 19, e7: 20, f7: 21, g7: 22, h7: 23,\n    a6: 32, b6: 33, c6: 34, d6: 35, e6: 36, f6: 37, g6: 38, h6: 39,\n    a5: 48, b5: 49, c5: 50, d5: 51, e5: 52, f5: 53, g5: 54, h5: 55,\n    a4: 64, b4: 65, c4: 66, d4: 67, e4: 68, f4: 69, g4: 70, h4: 71,\n    a3: 80, b3: 81, c3: 82, d3: 83, e3: 84, f3: 85, g3: 86, h3: 87,\n    a2: 96, b2: 97, c2: 98, d2: 99, e2: 100, f2: 101, g2: 102, h2: 103,\n    a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n}\n\nconst ROOKS = {\n    w: [\n        {square: SQUARE_MAP.a1, flag: BITS.QSIDE_CASTLE},\n        {square: SQUARE_MAP.h1, flag: BITS.KSIDE_CASTLE},\n    ],\n    b: [\n        {square: SQUARE_MAP.a8, flag: BITS.QSIDE_CASTLE},\n        {square: SQUARE_MAP.h8, flag: BITS.KSIDE_CASTLE},\n    ],\n}\n\nconst PARSER_STRICT = 0\nconst PARSER_SLOPPY = 1\n\n/* this function is used to uniquely identify ambiguous moves */\nfunction get_disambiguator(move, moves) {\n    var from = move.from\n    var to = move.to\n    var piece = move.piece\n\n    var ambiguities = 0\n    var same_rank = 0\n    var same_file = 0\n\n    for (var i = 0, len = moves.length; i < len; i++) {\n        var ambig_from = moves[i].from\n        var ambig_to = moves[i].to\n        var ambig_piece = moves[i].piece\n\n        /* if a move of the same piece type ends on the same to square, we'll\n         * need to add a disambiguator to the algebraic notation\n         */\n        if (piece === ambig_piece && from !== ambig_from && to === ambig_to) {\n            ambiguities++\n\n            if (rank(from) === rank(ambig_from)) {\n                same_rank++\n            }\n\n            if (file(from) === file(ambig_from)) {\n                same_file++\n            }\n        }\n    }\n\n    if (ambiguities > 0) {\n        /* if there exists a similar moving piece on the same rank and file as\n         * the move in question, use the square as the disambiguator\n         */\n        if (same_rank > 0 && same_file > 0) {\n            return algebraic(from)\n        } else if (same_file > 0) {\n            /* if the moving piece rests on the same file, use the rank symbol as the\n             * disambiguator\n             */\n            return algebraic(from).charAt(1)\n        } else {\n            /* else use the file symbol */\n            return algebraic(from).charAt(0)\n        }\n    }\n\n    return ''\n}\n\nfunction infer_piece_type(san) {\n    var piece_type = san.charAt(0)\n    if (piece_type >= 'a' && piece_type <= 'h') {\n        var matches = san.match(/[a-h]\\d.*[a-h]\\d/)\n        if (matches) {\n            return undefined\n        }\n        return PAWN\n    }\n    piece_type = piece_type.toLowerCase()\n    if (piece_type === 'o') {\n        return KING\n    }\n    return piece_type\n}\n\n// parses all of the decorators out of a SAN string\nfunction stripped_san(move) {\n    return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n}\n\n/*****************************************************************************\n * UTILITY FUNCTIONS\n ****************************************************************************/\nfunction rank(i) {\n    return i >> 4\n}\n\nfunction file(i) {\n    return i & 15\n}\n\nfunction algebraic(i) {\n    var f = file(i),\n        r = rank(i)\n    return 'abcdefgh'.substring(f, f + 1) + '87654321'.substring(r, r + 1)\n}\n\nfunction swap_color(c) {\n    return c === WHITE ? BLACK : WHITE\n}\n\nfunction is_digit(c) {\n    return '0123456789'.indexOf(c) !== -1\n}\n\nfunction clone(obj) {\n    var dupe = obj instanceof Array ? [] : {}\n\n    for (var property in obj) {\n        if (typeof property === 'object') {\n            dupe[property] = clone(obj[property])\n        } else {\n            dupe[property] = obj[property]\n        }\n    }\n\n    return dupe\n}\n\nfunction trim(str) {\n    return str.replace(/^\\s+|\\s+$/g, '')\n}\n\n/***************************************************************************\n * PUBLIC CONSTANTS\n **************************************************************************/\n\nexport const BLACK = 'b'\nexport const WHITE = 'w'\n\nexport const EMPTY = -1\n\nexport const PAWN = 'p'\nexport const KNIGHT = 'n'\nexport const BISHOP = 'b'\nexport const ROOK = 'r'\nexport const QUEEN = 'q'\nexport const KING = 'k'\n\nexport const SQUARES = (function () {\n    /* from the ECMA-262 spec (section 12.6.4):\n     * \"The mechanics of enumerating the properties ... is\n     * implementation dependent\"\n     * so: for (var sq in SQUARES) { keys.push(sq); } might not be\n     * ordered correctly\n     */\n    var keys = []\n    for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n        if (i & 0x88) {\n            i += 7\n            continue\n        }\n        keys.push(algebraic(i))\n    }\n    return keys\n})()\n\nexport const FLAGS = {\n    NORMAL: 'n',\n    CAPTURE: 'c',\n    BIG_PAWN: 'b',\n    EP_CAPTURE: 'e',\n    PROMOTION: 'p',\n    KSIDE_CASTLE: 'k',\n    QSIDE_CASTLE: 'q',\n}\n\nexport const Chess = function (fen, options) {\n    var board = new Array(128)\n    var kings = {w: EMPTY, b: EMPTY}\n    var turn = WHITE\n    var castling = {w: 0, b: 0}\n    var ep_square = EMPTY\n    var half_moves = 0\n    var move_number = 1\n    var history = []\n    var header = {}\n    var comments = {}\n\n    var isChess960 = !!(options && options.chess960)\n\n    /* if the user passes in a fen string, load it, else default to\n     * starting position\n     */\n    if (typeof fen === 'undefined' || typeof fen === 'object') {\n        // allow calling new Chess({chess960:true})\n        if (typeof fen === 'object' && !options) {\n            options = fen\n            isChess960 = !!(options && options.chess960)\n        }\n        load(DEFAULT_POSITION)\n    } else {\n        load(fen)\n    }\n\n    function clear(keep_headers) {\n        if (typeof keep_headers === 'undefined') {\n            keep_headers = false\n        }\n\n        board = new Array(128)\n        kings = {w: EMPTY, b: EMPTY}\n        turn = WHITE\n        castling = {w: 0, b: 0}\n        ep_square = EMPTY\n        half_moves = 0\n        move_number = 1\n        history = []\n        if (!keep_headers) header = {}\n        comments = {}\n        update_setup(generate_fen())\n    }\n\n    function prune_comments() {\n        var reversed_history = []\n        var current_comments = {}\n        var copy_comment = function (fen) {\n            if (fen in comments) {\n                current_comments[fen] = comments[fen]\n            }\n        }\n        while (history.length > 0) {\n            reversed_history.push(undo_move())\n        }\n        copy_comment(generate_fen())\n        while (reversed_history.length > 0) {\n            make_move(reversed_history.pop())\n            copy_comment(generate_fen())\n        }\n        comments = current_comments\n    }\n\n    function reset() {\n        load(DEFAULT_POSITION)\n    }\n\n    function load(fen, keep_headers) {\n        if (typeof keep_headers === 'undefined') {\n            keep_headers = false\n        }\n\n        var tokens = fen.split(/\\s+/)\n        var position = tokens[0]\n        var square = 0\n\n        if (!validate_fen(fen).valid) {\n            return false\n        }\n\n        clear(keep_headers)\n\n        for (var i = 0; i < position.length; i++) {\n            var piece = position.charAt(i)\n\n            if (piece === '/') {\n                square += 8\n            } else if (is_digit(piece)) {\n                square += parseInt(piece, 10)\n            } else {\n                var color = piece < 'a' ? WHITE : BLACK\n                put({type: piece.toLowerCase(), color: color}, algebraic(square))\n                square++\n            }\n        }\n\n        turn = tokens[1]\n\n        if (tokens[2].indexOf('K') > -1) {\n            castling.w |= BITS.KSIDE_CASTLE\n        }\n        if (tokens[2].indexOf('Q') > -1) {\n            castling.w |= BITS.QSIDE_CASTLE\n        }\n        if (tokens[2].indexOf('k') > -1) {\n            castling.b |= BITS.KSIDE_CASTLE\n        }\n        if (tokens[2].indexOf('q') > -1) {\n            castling.b |= BITS.QSIDE_CASTLE\n        }\n\n        ep_square = tokens[3] === '-' ? EMPTY : SQUARE_MAP[tokens[3]]\n        half_moves = parseInt(tokens[4], 10)\n        move_number = parseInt(tokens[5], 10)\n\n        init_rooks()\n        update_setup(generate_fen())\n\n        return true\n    }\n\n    /* TODO: this function is pretty much crap - it validates structure but\n     * completely ignores content (e.g. doesn't verify that each side has a king)\n     * ... we should rewrite this, and ditch the silly error_number field while\n     * we're at it\n     */\n    function validate_fen(fen) {\n        var errors = {\n            0: 'No errors.',\n            1: 'FEN string must contain six space-delimited fields.',\n            2: '6th field (move number) must be a positive integer.',\n            3: '5th field (half move counter) must be a non-negative integer.',\n            4: '4th field (en-passant square) is invalid.',\n            5: '3rd field (castling availability) is invalid.',\n            6: '2nd field (side to move) is invalid.',\n            7: \"1st field (piece positions) does not contain 8 '/'-delimited rows.\",\n            8: '1st field (piece positions) is invalid [consecutive numbers].',\n            9: '1st field (piece positions) is invalid [invalid piece].',\n            10: '1st field (piece positions) is invalid [row too large].',\n            11: 'Illegal en-passant square',\n        }\n\n        /* 1st criterion: 6 space-seperated fields? */\n        var tokens = fen.split(/\\s+/)\n        if (tokens.length !== 6) {\n            return {valid: false, error_number: 1, error: errors[1]}\n        }\n\n        /* 2nd criterion: move number field is a integer value > 0? */\n        if (isNaN(parseInt(tokens[5])) || parseInt(tokens[5], 10) <= 0) {\n            return {valid: false, error_number: 2, error: errors[2]}\n        }\n\n        /* 3rd criterion: half move counter is an integer >= 0? */\n        if (isNaN(parseInt(tokens[4])) || parseInt(tokens[4], 10) < 0) {\n            return {valid: false, error_number: 3, error: errors[3]}\n        }\n\n        /* 4th criterion: 4th field is a valid e.p.-string? */\n        if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n            return {valid: false, error_number: 4, error: errors[4]}\n        }\n\n        /* 5th criterion: 3th field is a valid castle-string? */\n        if (!/^(KQ?k?q?|Qk?q?|kq?|q|-)$/.test(tokens[2])) {\n            return {valid: false, error_number: 5, error: errors[5]}\n        }\n\n        /* 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)? */\n        if (!/^(w|b)$/.test(tokens[1])) {\n            return {valid: false, error_number: 6, error: errors[6]}\n        }\n\n        /* 7th criterion: 1st field contains 8 rows? */\n        var rows = tokens[0].split('/')\n        if (rows.length !== 8) {\n            return {valid: false, error_number: 7, error: errors[7]}\n        }\n\n        /* 8th criterion: every row is valid? */\n        for (var i = 0; i < rows.length; i++) {\n            /* check for right sum of fields AND not two numbers in succession */\n            var sum_fields = 0\n            var previous_was_number = false\n\n            for (var k = 0; k < rows[i].length; k++) {\n                if (!isNaN(rows[i][k])) {\n                    if (previous_was_number) {\n                        return {valid: false, error_number: 8, error: errors[8]}\n                    }\n                    sum_fields += parseInt(rows[i][k], 10)\n                    previous_was_number = true\n                } else {\n                    if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n                        return {valid: false, error_number: 9, error: errors[9]}\n                    }\n                    sum_fields += 1\n                    previous_was_number = false\n                }\n            }\n            if (sum_fields !== 8) {\n                return {valid: false, error_number: 10, error: errors[10]}\n            }\n        }\n\n        if (\n            (tokens[3][1] == '3' && tokens[1] == 'w') ||\n            (tokens[3][1] == '6' && tokens[1] == 'b')\n        ) {\n            return {valid: false, error_number: 11, error: errors[11]}\n        }\n\n        /* everything's okay! */\n        return {valid: true, error_number: 0, error: errors[0]}\n    }\n\n    function generate_fen() {\n        var empty = 0\n        var fen = ''\n\n        for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n            if (board[i] == null) {\n                empty++\n            } else {\n                if (empty > 0) {\n                    fen += empty\n                    empty = 0\n                }\n                var color = board[i].color\n                var piece = board[i].type\n\n                fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n            }\n\n            if ((i + 1) & 0x88) {\n                if (empty > 0) {\n                    fen += empty\n                }\n\n                if (i !== SQUARE_MAP.h1) {\n                    fen += '/'\n                }\n\n                empty = 0\n                i += 8\n            }\n        }\n\n        var cflags = ''\n        if (castling[WHITE] & BITS.KSIDE_CASTLE) {\n            cflags += 'K'\n        }\n        if (castling[WHITE] & BITS.QSIDE_CASTLE) {\n            cflags += 'Q'\n        }\n        if (castling[BLACK] & BITS.KSIDE_CASTLE) {\n            cflags += 'k'\n        }\n        if (castling[BLACK] & BITS.QSIDE_CASTLE) {\n            cflags += 'q'\n        }\n\n        /* do we have an empty castling flag? */\n        cflags = cflags || '-'\n        var epflags = ep_square === EMPTY ? '-' : algebraic(ep_square)\n\n        return [fen, turn, cflags, epflags, half_moves, move_number].join(' ')\n    }\n\n    function set_header(args) {\n        for (var i = 0; i < args.length; i += 2) {\n            if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n                header[args[i]] = args[i + 1]\n            }\n        }\n        return header\n    }\n\n    /* called when the initial board setup is changed with put() or remove().\n     * modifies the SetUp and FEN properties of the header object.  if the FEN is\n     * equal to the default position, the SetUp and FEN are deleted\n     * the setup is only updated if history.length is zero, ie moves haven't been\n     * made.\n     */\n    function update_setup(fen) {\n        if (history.length > 0) return\n\n        if (fen !== DEFAULT_POSITION) {\n            header['SetUp'] = '1'\n            header['FEN'] = fen\n        } else {\n            delete header['SetUp']\n            delete header['FEN']\n        }\n    }\n\n    function get(square) {\n        var piece = board[SQUARE_MAP[square]]\n        return piece ? {type: piece.type, color: piece.color} : null\n    }\n\n    function put(piece, square) {\n        /* check for valid piece object */\n        if (!('type' in piece && 'color' in piece)) {\n            return false\n        }\n\n        /* check for piece */\n        if (SYMBOLS.indexOf(piece.type.toLowerCase()) === -1) {\n            return false\n        }\n\n        /* check for valid square */\n        if (!(square in SQUARE_MAP)) {\n            return false\n        }\n\n        var sq = SQUARE_MAP[square]\n\n        /* don't let the user place more than one king */\n        if (\n            piece.type == KING &&\n            !(kings[piece.color] == EMPTY || kings[piece.color] == sq)\n        ) {\n            return false\n        }\n\n        board[sq] = {type: piece.type, color: piece.color}\n        if (piece.type === KING) {\n            kings[piece.color] = sq\n        }\n\n        update_setup(generate_fen())\n\n        return true\n    }\n\n    function remove(square) {\n        var piece = get(square)\n        board[SQUARE_MAP[square]] = null\n        if (piece && piece.type === KING) {\n            kings[piece.color] = EMPTY\n        }\n\n        update_setup(generate_fen())\n\n        return piece\n    }\n\n    function init_rooks() {\n        // if (!isChess960) return\n        function set_for(color) {\n            // find king and rooks on back rank\n            var ksq = kings[color]\n            if (ksq === EMPTY) return\n            var rk = rank(ksq)\n            var left_rook = null\n            var right_rook = null\n            for (var f = 0; f < 8; f++) {\n                var sq = (rk << 4) + f\n                var p = board[sq]\n                if (p && p.type === ROOK && p.color === color) {\n                    if (f < file(ksq)) {\n                        left_rook = sq\n                    } else if (f > file(ksq) && right_rook === null) {\n                        right_rook = sq\n                    }\n                }\n            }\n            if (left_rook != null) {\n                ROOKS[color][0].square = left_rook // QSIDE\n            }\n            if (right_rook != null) {\n                ROOKS[color][1].square = right_rook // KSIDE\n            }\n        }\n\n        set_for(WHITE)\n        set_for(BLACK)\n    }\n\n    function build_move(board, from, to, flags, promotion) {\n        var move = {\n            color: turn,\n            from: from,\n            to: to,\n            flags: flags,\n            piece: board[from].type,\n        }\n\n        if (promotion) {\n            move.flags |= BITS.PROMOTION\n            move.promotion = promotion\n        }\n\n        if (board[to]) {\n            move.captured = board[to].type\n        } else if (flags & BITS.EP_CAPTURE) {\n            move.captured = PAWN\n        }\n        return move\n    }\n\n    function generate_moves(options) {\n        function add_move(board, moves, from, to, flags) {\n            /* if pawn promotion */\n            if (\n                board[from].type === PAWN &&\n                (rank(to) === RANK_8 || rank(to) === RANK_1)\n            ) {\n                var pieces = [QUEEN, ROOK, BISHOP, KNIGHT]\n                for (var i = 0, len = pieces.length; i < len; i++) {\n                    moves.push(build_move(board, from, to, flags, pieces[i]))\n                }\n            } else {\n                moves.push(build_move(board, from, to, flags))\n            }\n        }\n\n        var moves = []\n        var us = turn\n        var them = swap_color(us)\n        var second_rank = {b: RANK_7, w: RANK_2}\n\n        var first_sq = SQUARE_MAP.a8\n        var last_sq = SQUARE_MAP.h1\n        var single_square = false\n\n        /* do we want legal moves? */\n        var legal =\n            typeof options !== 'undefined' && 'legal' in options\n                ? options.legal\n                : true\n\n        var piece_type =\n            typeof options !== 'undefined' &&\n            'piece' in options &&\n            typeof options.piece === 'string'\n                ? options.piece.toLowerCase()\n                : true\n\n        /* are we generating moves for a single square? */\n        if (typeof options !== 'undefined' && 'square' in options) {\n            if (options.square in SQUARE_MAP) {\n                first_sq = last_sq = SQUARE_MAP[options.square]\n                single_square = true\n            } else {\n                /* invalid square */\n                return []\n            }\n        }\n\n        for (var i = first_sq; i <= last_sq; i++) {\n            /* did we run off the end of the board */\n            if (i & 0x88) {\n                i += 7\n                continue\n            }\n\n            var piece = board[i]\n            if (piece == null || piece.color !== us) {\n                continue\n            }\n\n            if (piece.type === PAWN && (piece_type === true || piece_type === PAWN)) {\n                /* single square, non-capturing */\n                var square = i + PAWN_OFFSETS[us][0]\n                if (board[square] == null) {\n                    add_move(board, moves, i, square, BITS.NORMAL)\n\n                    /* double square */\n                    var square = i + PAWN_OFFSETS[us][1]\n                    if (second_rank[us] === rank(i) && board[square] == null) {\n                        add_move(board, moves, i, square, BITS.BIG_PAWN)\n                    }\n                }\n\n                /* pawn captures */\n                for (j = 2; j < 4; j++) {\n                    var square = i + PAWN_OFFSETS[us][j]\n                    if (square & 0x88) continue\n\n                    if (board[square] != null && board[square].color === them) {\n                        add_move(board, moves, i, square, BITS.CAPTURE)\n                    } else if (square === ep_square) {\n                        add_move(board, moves, i, ep_square, BITS.EP_CAPTURE)\n                    }\n                }\n            } else if (piece_type === true || piece_type === piece.type) {\n                for (var j = 0, len = PIECE_OFFSETS[piece.type].length; j < len; j++) {\n                    var offset = PIECE_OFFSETS[piece.type][j]\n                    var square = i\n\n                    while (true) {\n                        square += offset\n                        if (square & 0x88) break\n\n                        if (board[square] == null) {\n                            add_move(board, moves, i, square, BITS.NORMAL)\n                        } else {\n                            if (board[square].color === us) break\n                            add_move(board, moves, i, square, BITS.CAPTURE)\n                            break\n                        }\n\n                        /* break, if knight or king */\n                        if (piece.type === 'n' || piece.type === 'k') break\n                    }\n                }\n            }\n        }\n\n        /* check for castling if: a) we're generating all moves, or b) we're doing\n         * single square move generation on the king's square\n         */\n        if (piece_type === true || piece_type === KING) {\n            if (!single_square || last_sq === kings[us]) {\n                if (isChess960) {\n                    var kFrom = kings[us]\n                    var rankFrom = rank(kFrom)\n                    var kside = castling[us] & BITS.KSIDE_CASTLE\n                    var qside = castling[us] & BITS.QSIDE_CASTLE\n\n                    function path_clear_for_king(to, rookFrom) {\n                        if (to === kFrom) return true // rook-move-only castling: king doesn't move\n                        var step = file(to) > file(kFrom) ? 1 : -1\n                        for (var f = file(kFrom) + step; f != file(to) + step; f += step) {\n                            var sq = (rankFrom << 4) + f\n                            if (sq === rookFrom) continue\n                            if (sq !== kFrom && board[sq] != null) return false\n                        }\n                        return true\n                    }\n\n                    function king_path_safe(to) {\n                        // king cannot castle out of, through, or into check\n                        if (to === kFrom) {\n                            return !attacked(them, kFrom)\n                        }\n                        var step = file(to) > file(kFrom) ? 1 : -1\n                        if (attacked(them, kFrom)) return false\n                        for (var f = file(kFrom) + step; f != file(to) + step; f += step) {\n                            var sq = (rankFrom << 4) + f\n                            if (attacked(them, sq)) return false\n                        }\n                        return true\n                    }\n\n                    function path_clear_for_rook(rookFrom, rookTo) {\n                        var step = file(rookTo) > file(rookFrom) ? 1 : -1\n                        for (var f = file(rookFrom) + step; f != file(rookTo) + step; f += step) {\n                            var sq = (rankFrom << 4) + f\n                            if (sq === kFrom) continue\n                            if (board[sq] != null) return false\n                        }\n                        return true\n                    }\n\n                    if (kside) {\n                        var kTo = (rankFrom === RANK_1 ? SQUARE_MAP.g1 : SQUARE_MAP.g8)\n                        var rookFrom = ROOKS[us][1].square\n                        var rookTo = (rankFrom === RANK_1 ? SQUARE_MAP.f1 : SQUARE_MAP.f8)\n                        if (\n                            rookFrom != null &&\n                            path_clear_for_king(kTo, rookFrom) &&\n                            path_clear_for_rook(rookFrom, rookTo) &&\n                            king_path_safe(kTo)\n                        ) {\n                            add_move(board, moves, kFrom, kTo, BITS.KSIDE_CASTLE)\n                        }\n                    }\n\n                    if (qside) {\n                        var kToQ = (rankFrom === RANK_1 ? SQUARE_MAP.c1 : SQUARE_MAP.c8)\n                        var rookFromQ = ROOKS[us][0].square\n                        var rookToQ = (rankFrom === RANK_1 ? SQUARE_MAP.d1 : SQUARE_MAP.d8)\n                        if (\n                            rookFromQ != null &&\n                            path_clear_for_king(kToQ, rookFromQ) &&\n                            path_clear_for_rook(rookFromQ, rookToQ) &&\n                            king_path_safe(kToQ)\n                        ) {\n                            add_move(board, moves, kFrom, kToQ, BITS.QSIDE_CASTLE)\n                        }\n                    }\n                } else {\n                    /* king-side castling */\n                    if (castling[us] & BITS.KSIDE_CASTLE) {\n                        var castling_from = kings[us]\n                        var castling_to = castling_from + 2\n\n                        if (\n                            board[castling_from + 1] == null &&\n                            board[castling_to] == null &&\n                            !attacked(them, kings[us]) &&\n                            !attacked(them, castling_from + 1) &&\n                            !attacked(them, castling_to)\n                        ) {\n                            add_move(board, moves, kings[us], castling_to, BITS.KSIDE_CASTLE)\n                        }\n                    }\n\n                    /* queen-side castling */\n                    if (castling[us] & BITS.QSIDE_CASTLE) {\n                        var castling_from = kings[us]\n                        var castling_to = castling_from - 2\n\n                        if (\n                            board[castling_from - 1] == null &&\n                            board[castling_from - 2] == null &&\n                            board[castling_from - 3] == null &&\n                            !attacked(them, kings[us]) &&\n                            !attacked(them, castling_from - 1) &&\n                            !attacked(them, castling_to)\n                        ) {\n                            add_move(board, moves, kings[us], castling_to, BITS.QSIDE_CASTLE)\n                        }\n                    }\n                }\n            }\n        }\n\n        /* return all pseudo-legal moves (this includes moves that allow the king\n         * to be captured)\n         */\n        if (!legal) {\n            return moves\n        }\n\n        /* filter out illegal moves */\n        var legal_moves = []\n        for (var i = 0, len = moves.length; i < len; i++) {\n            make_move(moves[i])\n            if (!king_attacked(us)) {\n                legal_moves.push(moves[i])\n            }\n            undo_move()\n        }\n\n        return legal_moves\n    }\n\n    /* convert a move from 0x88 coordinates to Standard Algebraic Notation\n     * (SAN)\n     *\n     * @param {boolean} sloppy Use the sloppy SAN generator to work around over\n     * disambiguation bugs in Fritz and Chessbase.  See below:\n     *\n     * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n     * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n     * 4. ... Ne7 is technically the valid SAN\n     */\n    function move_to_san(move, moves) {\n        var output = ''\n\n        if (move.flags & BITS.KSIDE_CASTLE) {\n            output = 'O-O'\n        } else if (move.flags & BITS.QSIDE_CASTLE) {\n            output = 'O-O-O'\n        } else {\n            if (move.piece !== PAWN) {\n                var disambiguator = get_disambiguator(move, moves)\n                output += move.piece.toUpperCase() + disambiguator\n            }\n\n            if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n                if (move.piece === PAWN) {\n                    output += algebraic(move.from)[0]\n                }\n                output += 'x'\n            }\n\n            output += algebraic(move.to)\n\n            if (move.flags & BITS.PROMOTION) {\n                output += '=' + move.promotion.toUpperCase()\n            }\n        }\n\n        make_move(move)\n        if (in_check()) {\n            if (in_checkmate()) {\n                output += '#'\n            } else {\n                output += '+'\n            }\n        }\n        undo_move()\n\n        return output\n    }\n\n    function attacked(color, square) {\n        for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n            /* did we run off the end of the board */\n            if (i & 0x88) {\n                i += 7\n                continue\n            }\n\n            /* if empty square or wrong color */\n            if (board[i] == null || board[i].color !== color) continue\n\n            var piece = board[i]\n            var difference = i - square\n            var index = difference + 119\n\n            if (ATTACKS[index] & (1 << SHIFTS[piece.type])) {\n                if (piece.type === PAWN) {\n                    if (difference > 0) {\n                        if (piece.color === WHITE) return true\n                    } else {\n                        if (piece.color === BLACK) return true\n                    }\n                    continue\n                }\n\n                /* if the piece is a knight or a king */\n                if (piece.type === 'n' || piece.type === 'k') return true\n\n                var offset = RAYS[index]\n                var j = i + offset\n\n                var blocked = false\n                while (j !== square) {\n                    if (board[j] != null) {\n                        blocked = true\n                        break\n                    }\n                    j += offset\n                }\n\n                if (!blocked) return true\n            }\n        }\n\n        return false\n    }\n\n    function king_attacked(color) {\n        return attacked(swap_color(color), kings[color])\n    }\n\n    function in_check() {\n        return king_attacked(turn)\n    }\n\n    function in_checkmate() {\n        return in_check() && generate_moves().length === 0\n    }\n\n    function in_stalemate() {\n        return !in_check() && generate_moves().length === 0\n    }\n\n    function insufficient_material() {\n        var pieces = {}\n        var bishops = []\n        var num_pieces = 0\n        var sq_color = 0\n\n        for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n            sq_color = (sq_color + 1) % 2\n            if (i & 0x88) {\n                i += 7\n                continue\n            }\n\n            var piece = board[i]\n            if (piece) {\n                pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\n                if (piece.type === BISHOP) {\n                    bishops.push(sq_color)\n                }\n                num_pieces++\n            }\n        }\n\n        /* k vs. k */\n        if (num_pieces === 2) {\n            return true\n        } else if (\n            /* k vs. kn .... or .... k vs. kb */\n            num_pieces === 3 &&\n            (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\n        ) {\n            return true\n        } else if (num_pieces === pieces[BISHOP] + 2) {\n            /* kb vs. kb where any number of bishops are all on the same color */\n            var sum = 0\n            var len = bishops.length\n            for (var i = 0; i < len; i++) {\n                sum += bishops[i]\n            }\n            if (sum === 0 || sum === len) {\n                return true\n            }\n        }\n\n        return false\n    }\n\n    function in_threefold_repetition() {\n        /* TODO: while this function is fine for casual use, a better\n         * implementation would use a Zobrist key (instead of FEN). the\n         * Zobrist key would be maintained in the make_move/undo_move functions,\n         * avoiding the costly that we do below.\n         */\n        var moves = []\n        var positions = {}\n        var repetition = false\n\n        while (true) {\n            var move = undo_move()\n            if (!move) break\n            moves.push(move)\n        }\n\n        while (true) {\n            /* remove the last two fields in the FEN string, they're not needed\n             * when checking for draw by rep */\n            var fen = generate_fen().split(' ').slice(0, 4).join(' ')\n\n            /* has the position occurred three or move times */\n            positions[fen] = fen in positions ? positions[fen] + 1 : 1\n            if (positions[fen] >= 3) {\n                repetition = true\n            }\n\n            if (!moves.length) {\n                break\n            }\n            make_move(moves.pop())\n        }\n\n        return repetition\n    }\n\n    function push(move) {\n        history.push({\n            move: move,\n            kings: {b: kings.b, w: kings.w},\n            turn: turn,\n            castling: {b: castling.b, w: castling.w},\n            ep_square: ep_square,\n            half_moves: half_moves,\n            move_number: move_number,\n        })\n    }\n\n    function make_move(move) {\n        var us = turn\n        var them = swap_color(us)\n        push(move)\n\n        // Special handling for Chess960 castling where the king may not move (rook-move-only)\n        var is960Castle = isChess960 && (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) && board[move.from] && board[move.from].type === KING\n        if (is960Castle) {\n            var rankSide = rank(move.from)\n            var isK = !!(move.flags & BITS.KSIDE_CASTLE)\n            var rookFromC = isK ? ROOKS[us][1].square : ROOKS[us][0].square\n            var rookToC = isK\n                ? (rankSide === RANK_1 ? SQUARE_MAP.f1 : SQUARE_MAP.f8)\n                : (rankSide === RANK_1 ? SQUARE_MAP.d1 : SQUARE_MAP.d8)\n\n            // Handle different Chess960 castling scenarios\n            if (move.to !== move.from) {\n                // King actually moves\n                if (rookFromC === move.to) {\n                    // Rook sits on king's destination (transposition castling)\n                    // This is often a swap: king and rook exchange positions\n                    var kingPiece = board[move.from]\n                    var rookPiece = board[rookFromC]\n                    // Place both pieces at their destinations\n                    board[move.to] = kingPiece\n                    board[rookToC] = rookPiece\n                    // Only clear squares that aren't destinations\n                    // If rookToC === move.from, it's a perfect swap, no clearing needed\n                    // Otherwise clear the squares that are now empty\n                    if (rookToC !== move.from) {\n                        board[move.from] = null\n                    }\n                    if (rookFromC !== move.to && rookFromC !== rookToC && rookFromC !== move.from) {\n                        board[rookFromC] = null\n                    }\n                } else if (rookFromC === move.from) {\n                    // Rook and king start on same square\n                    // Move king first\n                    board[move.to] = board[move.from]\n                    board[move.from] = null\n                    // Now place the rook at its destination (which might be the same square)\n                    if (rookToC !== move.from) {\n                        // Rook needs to move to a different square\n                        board[rookToC] = {type: ROOK, color: us}\n                    } else {\n                        // Rook stays at the same square where king and rook started\n                        board[rookFromC] = {type: ROOK, color: us}\n                    }\n                } else {\n                    // Normal case - king and rook on different squares, neither on each other's destination\n                    // Move king\n                    board[move.to] = board[move.from]\n                    board[move.from] = null\n                    // Rook will be moved in the section below (lines 1196-1223)\n                }\n            } else {\n                // Rook-move-only castling: king stays in place, only move rook\n                board[rookToC] = board[rookFromC]\n                board[rookFromC] = null\n            }\n        } else {\n            board[move.to] = board[move.from]\n            board[move.from] = null\n        }\n\n        /* if ep capture, remove the captured pawn */\n        if (move.flags & BITS.EP_CAPTURE) {\n            if (turn === BLACK) {\n                board[move.to - 16] = null\n            } else {\n                board[move.to + 16] = null\n            }\n        }\n\n        /* if pawn promotion, replace with new piece */\n        if (move.flags & BITS.PROMOTION) {\n            board[move.to] = {type: move.promotion, color: us}\n        }\n\n        /* if we moved the king */\n        if (board[move.to] && board[move.to].type === KING) {\n            kings[board[move.to].color] = move.to\n\n            /* if we castled, move the rook to its final square (when king actually moved) */\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                if (isChess960) {\n                    // If the king didn't move (rook-move-only), this was already handled above\n                    if (move.to !== move.from) {\n                        var rTo = (rank(move.to) === RANK_1 ? SQUARE_MAP.f1 : SQUARE_MAP.f8)\n                        var rFrom = ROOKS[us][1].square\n                        // Only move rook if:\n                        // 1. It wasn't already handled above (when rook and king started on same square)\n                        // 2. The rook is not already at its destination\n                        // 3. The destination is empty or doesn't have a rook already\n                        if (rFrom !== move.from && rFrom !== rTo && (board[rTo] == null || (board[rTo] && board[rTo].type !== ROOK))) {\n                            board[rTo] = board[rFrom]\n                            board[rFrom] = null\n                        }\n                    }\n                } else {\n                    var castling_to = move.to - 1\n                    var castling_from = move.to + 1\n                    board[castling_to] = board[castling_from]\n                    board[castling_from] = null\n                }\n            } else if (move.flags & BITS.QSIDE_CASTLE) {\n                if (isChess960) {\n                    if (move.to !== move.from) {\n                        var rToQ = (rank(move.to) === RANK_1 ? SQUARE_MAP.d1 : SQUARE_MAP.d8)\n                        var rFromQ = ROOKS[us][0].square\n                        // Only move rook if:\n                        // 1. It wasn't already handled above (when rook and king started on same square)\n                        // 2. The rook is not already at its destination\n                        // 3. The destination is empty or doesn't have a rook already\n                        if (rFromQ !== move.from && rFromQ !== rToQ && (board[rToQ] == null || (board[rToQ] && board[rToQ].type !== ROOK))) {\n                            board[rToQ] = board[rFromQ]\n                            board[rFromQ] = null\n                        }\n                    }\n                } else {\n                    var castling_to = move.to + 1\n                    var castling_from = move.to - 2\n                    board[castling_to] = board[castling_from]\n                    board[castling_from] = null\n                }\n            }\n\n            /* turn off castling */\n            castling[us] = ''\n        }\n\n        /* turn off castling if we move a rook */\n        if (castling[us]) {\n            for (var i = 0, len = ROOKS[us].length; i < len; i++) {\n                if (\n                    move.from === ROOKS[us][i].square &&\n                    castling[us] & ROOKS[us][i].flag\n                ) {\n                    castling[us] ^= ROOKS[us][i].flag\n                    break\n                }\n            }\n        }\n\n        /* turn off castling if we capture a rook */\n        if (castling[them]) {\n            for (var i = 0, len = ROOKS[them].length; i < len; i++) {\n                if (\n                    move.to === ROOKS[them][i].square &&\n                    castling[them] & ROOKS[them][i].flag\n                ) {\n                    castling[them] ^= ROOKS[them][i].flag\n                    break\n                }\n            }\n        }\n\n        /* if big pawn move, update the en passant square */\n        if (move.flags & BITS.BIG_PAWN) {\n            if (turn === 'b') {\n                ep_square = move.to - 16\n            } else {\n                ep_square = move.to + 16\n            }\n        } else {\n            ep_square = EMPTY\n        }\n\n        /* reset the 50 move counter if a pawn is moved or a piece is captured */\n        if (move.piece === PAWN) {\n            half_moves = 0\n        } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n            half_moves = 0\n        } else {\n            half_moves++\n        }\n\n        if (turn === BLACK) {\n            move_number++\n        }\n        turn = swap_color(turn)\n    }\n\n    function undo_move() {\n        var old = history.pop()\n        if (old == null) {\n            return null\n        }\n\n        var move = old.move\n        kings = old.kings\n        turn = old.turn\n        castling = old.castling\n        ep_square = old.ep_square\n        half_moves = old.half_moves\n        move_number = old.move_number\n\n        var us = turn\n        var them = swap_color(turn)\n\n        // For Chess960 castling, we need to handle rook restoration first in some cases\n        var is960CastleUndo = isChess960 && (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE))\n\n        if (is960CastleUndo) {\n            // Handle Chess960 castling undo specially\n            var rFromU, rToU\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                rFromU = ROOKS[us][1].square\n                rToU = (rank(move.to) === RANK_1 ? SQUARE_MAP.f1 : SQUARE_MAP.f8)\n            } else {\n                rFromU = ROOKS[us][0].square\n                rToU = (rank(move.to) === RANK_1 ? SQUARE_MAP.d1 : SQUARE_MAP.d8)\n            }\n\n            // Check if this was a transposition castle (rook at king's destination)\n            var wasTransposition = rFromU === move.to\n\n            if (move.from === move.to) {\n                // Rook-move-only castling - only restore rook\n                if (rFromU !== rToU) {\n                    board[rFromU] = board[rToU]\n                    board[rToU] = null\n                }\n            } else if (wasTransposition) {\n                // King and rook swapped positions - restore both carefully\n                // After castling: board[move.to] has king, board[rToU] has rook\n                // Need to restore: king to move.from, rook to move.to (rFromU)\n                var kingPiece = board[move.to]\n                var rookPiece = board[rToU]\n                board[move.from] = kingPiece\n                board[rFromU] = rookPiece\n                // Only clear squares if they aren't being used by the restored pieces\n                if (move.to !== rFromU) {\n                    board[move.to] = null\n                }\n                if (rToU !== move.from && rToU !== rFromU) {\n                    board[rToU] = null\n                }\n            } else if (rFromU === move.from) {\n                // King and rook started on same square\n                board[move.from] = board[move.to]\n                board[move.to] = null\n                // Rook was placed separately, may need to be removed\n                if (rToU !== move.from && board[rToU] && board[rToU].type === ROOK) {\n                    board[rToU] = null\n                }\n            } else {\n                // Normal Chess960 castle - undo king move first\n                board[move.from] = board[move.to]\n                board[move.to] = null\n                // Then restore rook if it moved\n                if (rFromU !== rToU) {\n                    board[rFromU] = board[rToU]\n                    board[rToU] = null\n                }\n            }\n        } else {\n            // Standard chess or non-castling move\n            if (board[move.to]) {\n                board[move.from] = board[move.to]\n                board[move.from].type = move.piece // to undo any promotions\n                board[move.to] = null\n            }\n        }\n\n        if (move.flags & BITS.CAPTURE) {\n            board[move.to] = {type: move.captured, color: them}\n        } else if (move.flags & BITS.EP_CAPTURE) {\n            var index\n            if (us === BLACK) {\n                index = move.to - 16\n            } else {\n                index = move.to + 16\n            }\n            board[index] = {type: PAWN, color: them}\n        }\n\n        if (!is960CastleUndo && move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n            // Standard chess castling undo\n            var castling_to, castling_from\n            if (move.flags & BITS.KSIDE_CASTLE) {\n                castling_to = move.to + 1\n                castling_from = move.to - 1\n            } else if (move.flags & BITS.QSIDE_CASTLE) {\n                castling_to = move.to - 2\n                castling_from = move.to + 1\n            }\n\n            board[castling_to] = board[castling_from]\n            board[castling_from] = null\n        }\n\n        return move\n    }\n\n    // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n    function move_from_san(move, sloppy) {\n        // strip off any move decorations: e.g Nf3+?! becomes Nf3\n        var clean_move = stripped_san(move)\n\n        // the move parsers is a 2-step state\n        for (var parser = 0; parser < 2; parser++) {\n            if (parser == PARSER_SLOPPY) {\n                // only run the sloppy parse if explicitly requested\n                if (!sloppy) {\n                    return null\n                }\n\n                // The sloppy parser allows the user to parse non-standard chess\n                // notations. This parser is opt-in (by specifying the\n                // '{ sloppy: true }' setting) and is only run after the Standard\n                // Algebraic Notation (SAN) parser has failed.\n                //\n                // When running the sloppy parser, we'll run a regex to grab the piece,\n                // the to/from square, and an optional promotion piece. This regex will\n                // parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n                // f7f8q, b1c3\n\n                // NOTE: Some positions and moves may be ambiguous when using the\n                // sloppy parser. For example, in this position:\n                // 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1, the move b1c3 may be interpreted\n                // as Nc3 or B1c3 (a disambiguated bishop move). In these cases, the\n                // sloppy parser will default to the most most basic interpretation\n                // (which is b1c3 parsing to Nc3).\n\n                // FIXME: these var's are hoisted into function scope, this will need\n                // to change when switching to const/let\n\n                var overly_disambiguated = false\n\n                var matches = clean_move.match(\n                    /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/\n                )\n                if (matches) {\n                    var piece = matches[1]\n                    var from = matches[2]\n                    var to = matches[3]\n                    var promotion = matches[4]\n\n                    if (from.length == 1) {\n                        overly_disambiguated = true\n                    }\n                } else {\n                    // The [a-h]?[1-8]? portion of the regex below handles moves that may\n                    // be overly disambiguated (e.g. Nge7 is unnecessary and non-standard\n                    // when there is one legal knight move to e7). In this case, the value\n                    // of 'from' variable will be a rank or file, not a square.\n                    var matches = clean_move.match(\n                        /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/\n                    )\n\n                    if (matches) {\n                        var piece = matches[1]\n                        var from = matches[2]\n                        var to = matches[3]\n                        var promotion = matches[4]\n\n                        if (from.length == 1) {\n                            var overly_disambiguated = true\n                        }\n                    }\n                }\n            }\n\n            var piece_type = infer_piece_type(clean_move)\n            var moves = generate_moves({\n                legal: true,\n                piece: piece ? piece : piece_type,\n            })\n\n            for (var i = 0, len = moves.length; i < len; i++) {\n                switch (parser) {\n                    case PARSER_STRICT: {\n                        if (clean_move === stripped_san(move_to_san(moves[i], moves))) {\n                            return moves[i]\n                        }\n                        break\n                    }\n                    case PARSER_SLOPPY: {\n                        if (matches) {\n                            // hand-compare move properties with the results from our sloppy\n                            // regex\n                            if (\n                                (!piece || piece.toLowerCase() == moves[i].piece) &&\n                                SQUARE_MAP[from] == moves[i].from &&\n                                SQUARE_MAP[to] == moves[i].to &&\n                                (!promotion || promotion.toLowerCase() == moves[i].promotion)\n                            ) {\n                                return moves[i]\n                            } else if (overly_disambiguated) {\n                                // SPECIAL CASE: we parsed a move string that may have an\n                                // unneeded rank/file disambiguator (e.g. Nge7).  The 'from'\n                                // variable will\n                                var square = algebraic(moves[i].from)\n                                if (\n                                    (!piece || piece.toLowerCase() == moves[i].piece) &&\n                                    SQUARE_MAP[to] == moves[i].to &&\n                                    (from == square[0] || from == square[1]) &&\n                                    (!promotion || promotion.toLowerCase() == moves[i].promotion)\n                                ) {\n                                    return moves[i]\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return null\n    }\n\n    /* pretty = external move object */\n    function make_pretty(ugly_move) {\n        var move = clone(ugly_move)\n        move.san = move_to_san(move, generate_moves({legal: true}))\n        move.to = algebraic(move.to)\n        move.from = algebraic(move.from)\n\n        var flags = ''\n\n        for (var flag in BITS) {\n            if (BITS[flag] & move.flags) {\n                flags += FLAGS[flag]\n            }\n        }\n        move.flags = flags\n\n        return move\n    }\n\n    /*****************************************************************************\n     * DEBUGGING UTILITIES\n     ****************************************************************************/\n    function perft(depth) {\n        var moves = generate_moves({legal: false})\n        var nodes = 0\n        var color = turn\n\n        for (var i = 0, len = moves.length; i < len; i++) {\n            make_move(moves[i])\n            if (!king_attacked(color)) {\n                if (depth - 1 > 0) {\n                    var child_nodes = perft(depth - 1)\n                    nodes += child_nodes\n                } else {\n                    nodes++\n                }\n            }\n            undo_move()\n        }\n\n        return nodes\n    }\n\n    return {\n        /***************************************************************************\n         * PUBLIC API\n         **************************************************************************/\n        load: function (fen) {\n            return load(fen)\n        },\n\n        reset: function () {\n            return reset()\n        },\n\n        moves: function (options) {\n            /* The internal representation of a chess move is in 0x88 format, and\n             * not meant to be human-readable.  The code below converts the 0x88\n             * square coordinates to algebraic coordinates.  It also prunes an\n             * unnecessary move keys resulting from a verbose call.\n             */\n\n            var ugly_moves = generate_moves(options)\n            var moves = []\n\n            for (var i = 0, len = ugly_moves.length; i < len; i++) {\n                /* does the user want a full move object (most likely not), or just\n                 * SAN\n                 */\n                if (\n                    typeof options !== 'undefined' &&\n                    'verbose' in options &&\n                    options.verbose\n                ) {\n                    moves.push(make_pretty(ugly_moves[i]))\n                } else {\n                    moves.push(\n                        move_to_san(ugly_moves[i], generate_moves({legal: true}))\n                    )\n                }\n            }\n\n            return moves\n        },\n\n        in_check: function () {\n            return in_check()\n        },\n\n        in_checkmate: function () {\n            return in_checkmate()\n        },\n\n        in_stalemate: function () {\n            return in_stalemate()\n        },\n\n        in_draw: function () {\n            return (\n                half_moves >= 100 ||\n                in_stalemate() ||\n                insufficient_material() ||\n                in_threefold_repetition()\n            )\n        },\n\n        insufficient_material: function () {\n            return insufficient_material()\n        },\n\n        in_threefold_repetition: function () {\n            return in_threefold_repetition()\n        },\n\n        chess960: function () {\n            return isChess960\n        },\n\n        game_over: function () {\n            return (\n                half_moves >= 100 ||\n                in_checkmate() ||\n                in_stalemate() ||\n                insufficient_material() ||\n                in_threefold_repetition()\n            )\n        },\n\n        validate_fen: function (fen) {\n            return validate_fen(fen)\n        },\n\n        fen: function () {\n            return generate_fen()\n        },\n\n        board: function () {\n            var output = [],\n                row = []\n\n            for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n                if (board[i] == null) {\n                    row.push(null)\n                } else {\n                    row.push({\n                        square: algebraic(i),\n                        type: board[i].type,\n                        color: board[i].color,\n                    })\n                }\n                if ((i + 1) & 0x88) {\n                    output.push(row)\n                    row = []\n                    i += 8\n                }\n            }\n\n            return output\n        },\n\n        pgn: function (options) {\n            /* using the specification from http://www.chessclub.com/help/PGN-spec\n             * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n             */\n            var newline =\n                typeof options === 'object' && typeof options.newline_char === 'string'\n                    ? options.newline_char\n                    : '\\n'\n            var max_width =\n                typeof options === 'object' && typeof options.max_width === 'number'\n                    ? options.max_width\n                    : 0\n            var result = []\n            var header_exists = false\n\n            /* add the PGN header information */\n            for (var i in header) {\n                /* TODO: order of enumerated properties in header object is not\n                 * guaranteed, see ECMA-262 spec (section 12.6.4)\n                 */\n                result.push('[' + i + ' \"' + header[i] + '\"]' + newline)\n                header_exists = true\n            }\n\n            if (header_exists && history.length) {\n                result.push(newline)\n            }\n\n            var append_comment = function (move_string) {\n                var comment = comments[generate_fen()]\n                if (typeof comment !== 'undefined') {\n                    var delimiter = move_string.length > 0 ? ' ' : ''\n                    move_string = `${move_string}${delimiter}{${comment}}`\n                }\n                return move_string\n            }\n\n            /* pop all of history onto reversed_history */\n            var reversed_history = []\n            while (history.length > 0) {\n                reversed_history.push(undo_move())\n            }\n\n            var moves = []\n            var move_string = ''\n\n            /* special case of a commented starting position with no moves */\n            if (reversed_history.length === 0) {\n                moves.push(append_comment(''))\n            }\n\n            /* build the list of moves.  a move_string looks like: \"3. e3 e6\" */\n            while (reversed_history.length > 0) {\n                move_string = append_comment(move_string)\n                var move = reversed_history.pop()\n\n                /* if the position started with black to move, start PGN with #. ... */\n                if (!history.length && move.color === 'b') {\n                    const prefix = `${move_number}. ...`\n                    /* is there a comment preceding the first move? */\n                    move_string = move_string ? `${move_string} ${prefix}` : prefix\n                } else if (move.color === 'w') {\n                    /* store the previous generated move_string if we have one */\n                    if (move_string.length) {\n                        moves.push(move_string)\n                    }\n                    move_string = move_number + '.'\n                }\n\n                move_string =\n                    move_string + ' ' + move_to_san(move, generate_moves({legal: true}))\n                make_move(move)\n            }\n\n            /* are there any other leftover moves? */\n            if (move_string.length) {\n                moves.push(append_comment(move_string))\n            }\n\n            /* is there a result? */\n            if (typeof header.Result !== 'undefined') {\n                moves.push(header.Result)\n            }\n\n            /* history should be back to what it was before we started generating PGN,\n             * so join together moves\n             */\n            if (max_width === 0) {\n                return result.join('') + moves.join(' ')\n            }\n\n            var strip = function () {\n                if (result.length > 0 && result[result.length - 1] === ' ') {\n                    result.pop()\n                    return true\n                }\n                return false\n            }\n\n            /* NB: this does not preserve comment whitespace. */\n            var wrap_comment = function (width, move) {\n                for (var token of move.split(' ')) {\n                    if (!token) {\n                        continue\n                    }\n                    if (width + token.length > max_width) {\n                        while (strip()) {\n                            width--\n                        }\n                        result.push(newline)\n                        width = 0\n                    }\n                    result.push(token)\n                    width += token.length\n                    result.push(' ')\n                    width++\n                }\n                if (strip()) {\n                    width--\n                }\n                return width\n            }\n\n            /* wrap the PGN output at max_width */\n            var current_width = 0\n            for (var i = 0; i < moves.length; i++) {\n                if (current_width + moves[i].length > max_width) {\n                    if (moves[i].includes('{')) {\n                        current_width = wrap_comment(current_width, moves[i])\n                        continue\n                    }\n                }\n                /* if the current move will push past max_width */\n                if (current_width + moves[i].length > max_width && i !== 0) {\n                    /* don't end the line with whitespace */\n                    if (result[result.length - 1] === ' ') {\n                        result.pop()\n                    }\n\n                    result.push(newline)\n                    current_width = 0\n                } else if (i !== 0) {\n                    result.push(' ')\n                    current_width++\n                }\n                result.push(moves[i])\n                current_width += moves[i].length\n            }\n\n            return result.join('')\n        },\n\n        load_pgn: function (pgn, options) {\n            // allow the user to specify the sloppy move parser to work around over\n            // disambiguation bugs in Fritz and Chessbase\n            var sloppy =\n                typeof options !== 'undefined' && 'sloppy' in options\n                    ? options.sloppy\n                    : false\n\n            function mask(str) {\n                return str.replace(/\\\\/g, '\\\\')\n            }\n\n            function parse_pgn_header(header, options) {\n                var newline_char =\n                    typeof options === 'object' &&\n                    typeof options.newline_char === 'string'\n                        ? options.newline_char\n                        : '\\r?\\n'\n                var header_obj = {}\n                var headers = header.split(new RegExp(mask(newline_char)))\n                var key = ''\n                var value = ''\n\n                for (var i = 0; i < headers.length; i++) {\n                    var regex = /^\\s*\\[([A-Za-z]+)\\s*\"(.*)\"\\s*\\]\\s*$/\n                    key = headers[i].replace(regex, '$1')\n                    value = headers[i].replace(regex, '$2')\n                    if (trim(key).length > 0) {\n                        header_obj[key] = value\n                    }\n                }\n\n                return header_obj\n            }\n\n            // strip whitespace from head/tail of PGN block\n            pgn = pgn.trim()\n\n            var newline_char =\n                typeof options === 'object' && typeof options.newline_char === 'string'\n                    ? options.newline_char\n                    : '\\r?\\n'\n\n            // RegExp to split header. Takes advantage of the fact that header and movetext\n            // will always have a blank line between them (ie, two newline_char's).\n            // With default newline_char, will equal: /^(\\[((?:\\r?\\n)|.)*\\])(?:\\s*\\r?\\n){2}/\n            var header_regex = new RegExp(\n                '^(\\\\[((?:' +\n                mask(newline_char) +\n                ')|.)*\\\\])' +\n                '(?:\\\\s*' +\n                mask(newline_char) +\n                '){2}'\n            )\n\n            // If no header given, begin with moves.\n            var header_string = header_regex.test(pgn)\n                ? header_regex.exec(pgn)[1]\n                : ''\n\n            // Put the board in the starting position\n            reset()\n\n            /* parse PGN header */\n            var headers = parse_pgn_header(header_string, options)\n            var fen = ''\n\n            for (var key in headers) {\n                // check to see user is including fen (possibly with wrong tag case)\n                if (key.toLowerCase() === 'fen') {\n                    fen = headers[key]\n                }\n                set_header([key, headers[key]])\n            }\n\n            /* sloppy parser should attempt to load a fen tag, even if it's\n             * the wrong case and doesn't include a corresponding [SetUp \"1\"] tag */\n            if (sloppy) {\n                if (fen) {\n                    if (!load(fen, true)) {\n                        return false\n                    }\n                }\n            } else {\n                /* strict parser - load the starting position indicated by [Setup '1']\n                 * and [FEN position] */\n                if (headers['SetUp'] === '1') {\n                    if (!('FEN' in headers && load(headers['FEN'], true))) {\n                        // second argument to load: don't clear the headers\n                        return false\n                    }\n                }\n            }\n\n            /* NB: the regexes below that delete move numbers, recursive\n             * annotations, and numeric annotation glyphs may also match\n             * text in comments. To prevent this, we transform comments\n             * by hex-encoding them in place and decoding them again after\n             * the other tokens have been deleted.\n             *\n             * While the spec states that PGN files should be ASCII encoded,\n             * we use {en,de}codeURIComponent here to support arbitrary UTF8\n             * as a convenience for modern users */\n\n            var to_hex = function (string) {\n                return Array.from(string)\n                    .map(function (c) {\n                        /* encodeURI doesn't transform most ASCII characters,\n                         * so we handle these ourselves */\n                        return c.charCodeAt(0) < 128\n                            ? c.charCodeAt(0).toString(16)\n                            : encodeURIComponent(c).replace(/\\%/g, '').toLowerCase()\n                    })\n                    .join('')\n            }\n\n            var from_hex = function (string) {\n                return string.length == 0\n                    ? ''\n                    : decodeURIComponent('%' + string.match(/.{1,2}/g).join('%'))\n            }\n\n            var encode_comment = function (string) {\n                string = string.replace(new RegExp(mask(newline_char), 'g'), ' ')\n                return `{${to_hex(string.slice(1, string.length - 1))}}`\n            }\n\n            var decode_comment = function (string) {\n                if (string.startsWith('{') && string.endsWith('}')) {\n                    return from_hex(string.slice(1, string.length - 1))\n                }\n            }\n\n            /* delete header to get the moves */\n            var ms = pgn\n                .replace(header_string, '')\n                .replace(\n                    /* encode comments so they don't get deleted below */\n                    new RegExp(`(\\{[^}]*\\})+?|;([^${mask(newline_char)}]*)`, 'g'),\n                    function (match, bracket, semicolon) {\n                        return bracket !== undefined\n                            ? encode_comment(bracket)\n                            : ' ' + encode_comment(`{${semicolon.slice(1)}}`)\n                    }\n                )\n                .replace(new RegExp(mask(newline_char), 'g'), ' ')\n\n            /* delete recursive annotation variations */\n            var rav_regex = /(\\([^\\(\\)]+\\))+?/g\n            while (rav_regex.test(ms)) {\n                ms = ms.replace(rav_regex, '')\n            }\n\n            /* delete move numbers */\n            ms = ms.replace(/\\d+\\.(\\.\\.)?/g, '')\n\n            /* delete ... indicating black to move */\n            ms = ms.replace(/\\.\\.\\./g, '')\n\n            /* delete numeric annotation glyphs */\n            ms = ms.replace(/\\$\\d+/g, '')\n\n            /* trim and get array of moves */\n            var moves = trim(ms).split(new RegExp(/\\s+/))\n\n            /* delete empty entries */\n            moves = moves.join(',').replace(/,,+/g, ',').split(',')\n            var move = ''\n\n            var result = ''\n\n            for (var half_move = 0; half_move < moves.length; half_move++) {\n                var comment = decode_comment(moves[half_move])\n                if (comment !== undefined) {\n                    comments[generate_fen()] = comment\n                    continue\n                }\n\n                move = move_from_san(moves[half_move], sloppy)\n\n                /* invalid move */\n                if (move == null) {\n                    /* was the move an end of game marker */\n                    if (TERMINATION_MARKERS.indexOf(moves[half_move]) > -1) {\n                        result = moves[half_move]\n                    } else {\n                        return false\n                    }\n                } else {\n                    /* reset the end of game marker if making a valid move */\n                    result = ''\n                    make_move(move)\n                }\n            }\n\n            /* Per section 8.2.6 of the PGN spec, the Result tag pair must match\n             * match the termination marker. Only do this when headers are present,\n             * but the result tag is missing\n             */\n            if (result && Object.keys(header).length && !header['Result']) {\n                set_header(['Result', result])\n            }\n\n            return true\n        },\n\n        header: function () {\n            return set_header(arguments)\n        },\n\n        turn: function () {\n            return turn\n        },\n\n        move: function (move, options) {\n            /* The move function can be called with in the following parameters:\n             *\n             * .move('Nxb7')      <- where 'move' is a case-sensitive SAN string\n             *\n             * .move({ from: 'h7', <- where the 'move' is a move object (additional\n             *         to :'h8',      fields are ignored)\n             *         promotion: 'q',\n             *      })\n             */\n\n            // allow the user to specify the sloppy move parser to work around over\n            // disambiguation bugs in Fritz and Chessbase\n            var sloppy =\n                typeof options !== 'undefined' && 'sloppy' in options\n                    ? options.sloppy\n                    : false\n\n            var move_obj = null\n\n            if (typeof move === 'string') {\n                move_obj = move_from_san(move, sloppy)\n            } else if (typeof move === 'object') {\n                var moves = generate_moves()\n\n                /* convert the pretty move object to an ugly move object */\n                for (var i = 0, len = moves.length; i < len; i++) {\n                    if (\n                        move.from === algebraic(moves[i].from) &&\n                        move.to === algebraic(moves[i].to) &&\n                        (!('promotion' in moves[i]) ||\n                            move.promotion === moves[i].promotion)\n                    ) {\n                        move_obj = moves[i]\n                        break\n                    }\n                }\n            }\n\n            /* failed to find move */\n            if (!move_obj) {\n                return null\n            }\n\n            /* need to make a copy of move because we can't generate SAN after the\n             * move is made\n             */\n            var pretty_move = make_pretty(move_obj)\n\n            make_move(move_obj)\n\n            return pretty_move\n        },\n\n        undo: function () {\n            var move = undo_move()\n            return move ? make_pretty(move) : null\n        },\n\n        clear: function () {\n            return clear()\n        },\n\n        put: function (piece, square) {\n            return put(piece, square)\n        },\n\n        get: function (square) {\n            return get(square)\n        },\n\n        ascii() {\n            var s = '   +------------------------+\\n'\n            for (var i = SQUARE_MAP.a8; i <= SQUARE_MAP.h1; i++) {\n                /* display the rank */\n                if (file(i) === 0) {\n                    s += ' ' + '87654321'[rank(i)] + ' |'\n                }\n\n                /* empty piece */\n                if (board[i] == null) {\n                    s += ' . '\n                } else {\n                    var piece = board[i].type\n                    var color = board[i].color\n                    var symbol =\n                        color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n                    s += ' ' + symbol + ' '\n                }\n\n                if ((i + 1) & 0x88) {\n                    s += '|\\n'\n                    i += 8\n                }\n            }\n            s += '   +------------------------+\\n'\n            s += '     a  b  c  d  e  f  g  h'\n\n            return s\n        },\n\n        remove: function (square) {\n            return remove(square)\n        },\n\n        perft: function (depth) {\n            return perft(depth)\n        },\n\n        square_color: function (square) {\n            if (square in SQUARE_MAP) {\n                var sq_0x88 = SQUARE_MAP[square]\n                return (rank(sq_0x88) + file(sq_0x88)) % 2 === 0 ? 'light' : 'dark'\n            }\n\n            return null\n        },\n\n        history: function (options) {\n            var reversed_history = []\n            var move_history = []\n            var verbose =\n                typeof options !== 'undefined' &&\n                'verbose' in options &&\n                options.verbose\n\n            while (history.length > 0) {\n                reversed_history.push(undo_move())\n            }\n\n            while (reversed_history.length > 0) {\n                var move = reversed_history.pop()\n                if (verbose) {\n                    move_history.push(make_pretty(move))\n                } else {\n                    move_history.push(move_to_san(move, generate_moves({legal: true})))\n                }\n                make_move(move)\n            }\n\n            return move_history\n        },\n\n        get_comment: function () {\n            return comments[generate_fen()]\n        },\n\n        set_comment: function (comment) {\n            comments[generate_fen()] = comment.replace('{', '[').replace('}', ']')\n        },\n\n        delete_comment: function () {\n            var comment = comments[generate_fen()]\n            delete comments[generate_fen()]\n            return comment\n        },\n\n        get_comments: function () {\n            prune_comments()\n            return Object.keys(comments).map(function (fen) {\n                return {fen: fen, comment: comments[fen]}\n            })\n        },\n\n        delete_comments: function () {\n            prune_comments()\n            return Object.keys(comments).map(function (fen) {\n                var comment = comments[fen]\n                delete comments[fen]\n                return {fen: fen, comment: comment}\n            })\n        },\n    }\n}"],
  "mappings": ";AA2BA,IAAM,UAAU;AAEhB,IAAM,mBACF;AAEJ,IAAM,sBAAsB,CAAC,OAAO,OAAO,WAAW,GAAG;AAEzD,IAAM,eAAe;AAAA,EACjB,GAAG,CAAC,IAAI,IAAI,IAAI,EAAE;AAAA,EAClB,GAAG,CAAC,KAAK,KAAK,KAAK,GAAG;AAC1B;AAEA,IAAM,gBAAgB;AAAA,EAClB,GAAG,CAAC,KAAK,KAAK,KAAK,KAAK,IAAI,IAAI,IAAI,EAAE;AAAA,EACtC,GAAG,CAAC,KAAK,KAAK,IAAI,EAAE;AAAA,EACpB,GAAG,CAAC,KAAK,GAAG,IAAI,EAAE;AAAA,EAClB,GAAG,CAAC,KAAK,KAAK,KAAK,GAAG,IAAI,IAAI,IAAI,EAAE;AAAA,EACpC,GAAG,CAAC,KAAK,KAAK,KAAK,GAAG,IAAI,IAAI,IAAI,EAAE;AACxC;AAGA,IAAM,UAAU;AAAA,EACZ;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAChD;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAC3D;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAChD;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAChD;AAGA,IAAM,OAAO;AAAA,EACT;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAChD;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAChD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EAAI;AAAA,EACpD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACnD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACnD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EACnD;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;AAAA,EAAK;AAAA,EAAG;AAAA,EAAG;AAAA,EAAG;A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",
  "names": ["fen", "board", "options", "moves", "i", "len", "rookFrom", "rookTo", "move_string", "move", "header", "newline_char", "headers", "key"]
}
